                    Arquivo README para o Trabalho Prático 3
================================================================================

Estrutura
---------

  Considere que <cool dir> corresponde ao caminho onde está a pasta "cool" que
  você extraiu do arquivo "tp3-4.tar.gz". Após executar o comando

  > make -f <cool dir>/assignments/parser/Makefile

  seu diretório deve conter os seguintes arquivos (-> corresponde a links
  simbólicos):

  Makefile                -> [cool dir]/src/parser/Makefile
  README
  cool.y
  bad.cl
  good.cl
  cool-tree.handcode.h
  cool-tree.cc            -> [cool dir]/src/parser/cool-tree.cc
  cool-tree.aps           -> [cool dir]/src/parser/cool-tree.aps
  dumptype.cc             -> [cool dir]/src/parser/dumptype.cc
  handle_flags.c          -> [cool dir]/src/parser/handle_flags.cc
  parser-phase.cc         -> [cool dir]/src/parser/parser-phase.cc
  stringtab.cc            -> [cool dir]/src/parser/stringtab.cc
  tokens-lex.cc           -> [cool dir]/src/parser/tokens-lex.cc
  tree.cc                 -> [cool dir]/src/parser/tree.cc
  utilities.cc            -> [cool dir]/src/parser/utilities.cc
  *.d                     dependency files
  *.*                     other generated files

  Os arquivos de cabeçalho (.h) para este trabalho podem ser encontrados em
  [cool dir]/include/parser.

  O Makefile contém ações para compilar e executar seu programa.
  NÃO MODIFIQUE.

  O README (este arquivo) contém algumas instruções. Além disso, você encontrará
  ao final do arquivo um espaço para que você preencha a documentação a ser
  entregue. Você deve explicar as decisões de projeto, explicar por que seu
  programa está correto e por que seus casos de teste são adequados. Ao final,
  antes de gerar o arquivo de submissão, apague todo o conteúdo do arquivo README
  que não faz parte da sua documentação (i.e. as instruções aqui presentes, acima
  dos dizeres "corte aqui"),

  cool.y contém um esqueleto inicial da especificação do parser que você irá
  escrever. Ele já contém algumas produções para programa e classes. Use-as como
  exemplo para escrever o restante das produções. Você deve, também, ler a
  documentação do bison.

  good.cl e bad.cl testam algumas características da gramática. Você deve
  adicionar testes para garantir que good.cl exercite qualquer construção legal e
  que bad.cl exercite a maior quantidade possível de erros que você consiga
  inserir em um único arquivo.

  cool-tree.aps contém as definições de árvore que você utilizará para construir
  a árvore de sintaxe abstrata (AST). A partir deste arquivo, cool-tree.h e
  cool-tree.cc são gerados automaticamente por um utilitário que compila a
  especificação para funções C++, para produzir e consumir nós de árvore.
  NÃO MODIFIQUE.

  tree.{cc|h} contém definições usadas pelo pacote de árvore.
  cool-tree.handcode.h é uma extensão de cool-tree.h escrita a mão. Se você ler
  os arquivos cool-tree.h e cool-tree.cc, você notará que existem "hooks" para
  estender declarações de classes. Estender e moficar o pacote de árvore é
  discutido em "Cool Tour", mas você não precisa modificar esse
  pacote para este trabalho.

  tokens-lex.cc é um analisador léxico capaz de ler uma sequência de tokens.
  NÃO MODIFIQUE.

  parser-phase.cc contém um driver para testar o parser. NÃO MODIFIQUE.

  dumptype.cc imprime a AST em um formato legível para a fase de análise
  semântica do compilador. NÃO MODIFIQUE.

  handle_flags.cc implementa rotinas para analisar opções passadas por linha de
  comando. NÃO MODIFIQUE.

  O restante dos arquivos são gerados pelo bison.
  cool-parse.cc é o arquivo C++ gerado que contém a implementação do parser.

Instruções
----------

  Para compilar seu parser, execute o seguinte comando:

  > make parser

  Isto irá produzer um executável chamado "parser", que corresponde somente a
  fase de análise sintática do compilador. Para fazer qualquer coisa útil, será
  necessário o analisador léxico (executável = lexer), semântico (executável =
  semant) e geração de código (executável = cgen).

  Para testar seu parser em um arquivo "foo.cl", execute o
  seguinte comando:

  > ./myparser foo.cl

  myparser é um arquivo shell script que une os analisadores léxico e
  sintático.

  Para aplicar seu parser aos arquivos good.cl e bad.cl, execute o comando:

  > make dotest

  Se você acredita que seu parser está correto, você pode querer
  rodar o compilador Cool completo. Para tanto, execute o
  seguinte comando:

  > ./mycoolc foo.cl -o foo.s

  mycoolc é um arquivo shell script que une as fases de compilação (léxico,
  sintático, semântico e geração de código). Você tem disponível
  também o coolc, uma versão de referência do compilador de
  Cool, caso queira utilizar:

  > ./coolc foo.cl -o foo.s

  E, caso queira testar o programa gerado, você pode utilizar o
  emulador spim:

  > ./spim -file foo.s

  Para entregar seu trabalho, primeiro certifique-se que está tudo funcionando
  e que você preencheu o arquivo README corretamente. Em seguida, dentro do
  diretório do projeto, execute o seguinte comando (considerando que apenas
  os arquivos a seguir foram modificados):

  > tar -czvf tp3_seuNOME.tar.gz cool.y good.cl bad.cl README

  BOA SORTE!

------8<------8<------8<------8<---corte arqui---8<------8<------8<------8<-----

[Aqui começa sua documentação]




Write-up for PA3
----------------

Cool syntax specification can be found in [The Cool Reference Manual](http://web.stanford.edu/class/cs143/materials/cool-manual.pdf). (Page 17)

### Write Parsing Rules

According to the definition of AST nodes in `cool-tree.aps`, you can write parsing rules easily in `cool.y`. For example, the definition of the constructor of `class` is as follows:

```cpp
constructor class_(name : Symbol; parent: Symbol;
    features : Features; filename : Symbol): Class_;
```

The parsing rule is as follows:

```cpp
class   : CLASS TYPEID '{' feature_list '}' ';' {
            $$ = class_($2, idtable.add_string("Object"), 
                $4, stringtable.add_string(curr_filename));
        }
        | CLASS TYPEID INHERITS TYPEID '{' feature_list '}' ';' {
            $$ = class_($2, $4, $6,
                stringtable.add_string(curr_filename));
        }
        ;
```

Attention that list phyla have a distinct set of operations for constructing and accessing lists. For each phylum named X there is a phylum called Xs (except for `Classes`, which is a list of Class nodes) of type List[X]. List functions are defined automatically for each list.

The function `nil_***()` returns an empty list of type phylum. The function `single_***()` makes a list of length 1 out of its phylum argument. The function `append_***()` appends two lists of phylums. For the example of `formal_list`, whose type is `Formals`:

```cpp
formal_list : {
                $$ = nil_Formals();
            }
            | formal {
                $$ = single_Formals($1);
            }
            | formal_list ',' formal {
                $$ = append_Formals($1, single_Formals($3));
            }
            ;
```

When you have completed all the parsing rules in `cool.y`, type `make parser` to build the parser. Yacc produces a human-readable dump of the LALR(1) parsing tables in the `cool.output`. You can check whether your parser has any shift-reduce conflicts.

The Cool `let` construct introduces an ambiguity into the language. The manual resolves the ambiguity by saying that a `let` expression extends as far to the right as possible.

### Error Handling

- If there is an error in a class definition but the class is terminated properly and the next class is syntactically correct, the parser should be able to restart at the next class definition.
- Similarly, the parser should recover from errors in features (going on to the next feature), a `let` binding (going on to the next variable), and an expression inside a `{...}` block.

So you should add the `error` pseudo-nontermina to the production of class, feature, and so on.

## Judge

`judge.sh` is a judge script which compares the output of my parser (`./parser`) with the reference parser (`../../bin/.i686/parser`).

Run `./judge.sh` or `bash judge.sh`, you should get the following results:

```
--------Test using ../../examples/arith.cl --------
Passed
--------Test using ../../examples/atoi.cl --------
Passed
--------Test using ../../examples/atoi_test.cl --------
Passed
--------Test using ../../examples/book_list.cl --------
Passed
--------Test using ../../examples/cells.cl --------
Passed
--------Test using ../../examples/complex.cl --------
Passed
--------Test using ../../examples/cool.cl --------
Passed
--------Test using ../../examples/good.cl --------
Passed
--------Test using ../../examples/graph.cl --------
Passed
--------Test using ../../examples/hairyscary.cl --------
Passed
--------Test using ../../examples/hello_world.cl --------
Passed
--------Test using ../../examples/io.cl --------
Passed
--------Test using ../../examples/lam.cl --------
Passed
--------Test using ../../examples/life.cl --------
Passed
--------Test using ../../examples/list.cl --------
Passed
--------Test using ../../examples/new_complex.cl --------
Passed
--------Test using ../../examples/palindrome.cl --------
Passed
--------Test using ../../examples/primes.cl --------
Passed
--------Test using ../../examples/sort_list.cl --------
Passed
```
