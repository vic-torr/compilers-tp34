                    Arquivo README para o Trabalho Prático 3
================================================================================

Estrutura
---------

  Considere que <cool dir> corresponde ao caminho onde está a pasta "cool" que
  você extraiu do arquivo "tp3-4.tar.gz". Após executar o comando

  > make -f <cool dir>/assignments/parser/Makefile

  seu diretório deve conter os seguintes arquivos (-> corresponde a links
  simbólicos):

  Makefile                -> [cool dir]/src/parser/Makefile
  README
  cool.y
  bad.cl
  good.cl
  cool-tree.handcode.h
  cool-tree.cc            -> [cool dir]/src/parser/cool-tree.cc
  cool-tree.aps           -> [cool dir]/src/parser/cool-tree.aps
  dumptype.cc             -> [cool dir]/src/parser/dumptype.cc
  handle_flags.c          -> [cool dir]/src/parser/handle_flags.cc
  parser-phase.cc         -> [cool dir]/src/parser/parser-phase.cc
  stringtab.cc            -> [cool dir]/src/parser/stringtab.cc
  tokens-lex.cc           -> [cool dir]/src/parser/tokens-lex.cc
  tree.cc                 -> [cool dir]/src/parser/tree.cc
  utilities.cc            -> [cool dir]/src/parser/utilities.cc
  *.d                     dependency files
  *.*                     other generated files

  Os arquivos de cabeçalho (.h) para este trabalho podem ser encontrados em
  [cool dir]/include/parser.

  O Makefile contém ações para compilar e executar seu programa.
  NÃO MODIFIQUE.

  O README (este arquivo) contém algumas instruções. Além disso, você encontrará
  ao final do arquivo um espaço para que você preencha a documentação a ser
  entregue. Você deve explicar as decisões de projeto, explicar por que seu
  programa está correto e por que seus casos de teste são adequados. Ao final,
  antes de gerar o arquivo de submissão, apague todo o conteúdo do arquivo README
  que não faz parte da sua documentação (i.e. as instruções aqui presentes, acima
  dos dizeres "corte aqui"),

  cool.y contém um esqueleto inicial da especificação do parser que você irá
  escrever. Ele já contém algumas produções para programa e classes. Use-as como
  exemplo para escrever o restante das produções. Você deve, também, ler a
  documentação do bison.

  good.cl e bad.cl testam algumas características da gramática. Você deve
  adicionar testes para garantir que good.cl exercite qualquer construção legal e
  que bad.cl exercite a maior quantidade possível de erros que você consiga
  inserir em um único arquivo.

  cool-tree.aps contém as definições de árvore que você utilizará para construir
  a árvore de sintaxe abstrata (AST). A partir deste arquivo, cool-tree.h e
  cool-tree.cc são gerados automaticamente por um utilitário que compila a
  especificação para funções C++, para produzir e consumir nós de árvore.
  NÃO MODIFIQUE.

  tree.{cc|h} contém definições usadas pelo pacote de árvore.
  cool-tree.handcode.h é uma extensão de cool-tree.h escrita a mão. Se você ler
  os arquivos cool-tree.h e cool-tree.cc, você notará que existem "hooks" para
  estender declarações de classes. Estender e moficar o pacote de árvore é
  discutido em "Cool Tour", mas você não precisa modificar esse
  pacote para este trabalho.

  tokens-lex.cc é um analisador léxico capaz de ler uma sequência de tokens.
  NÃO MODIFIQUE.

  parser-phase.cc contém um driver para testar o parser. NÃO MODIFIQUE.

  dumptype.cc imprime a AST em um formato legível para a fase de análise
  semântica do compilador. NÃO MODIFIQUE.

  handle_flags.cc implementa rotinas para analisar opções passadas por linha de
  comando. NÃO MODIFIQUE.

  O restante dos arquivos são gerados pelo bison.
  cool-parse.cc é o arquivo C++ gerado que contém a implementação do parser.

Instruções
----------

  Para compilar seu parser, execute o seguinte comando:

  > make parser

  Isto irá produzer um executável chamado "parser", que corresponde somente a
  fase de análise sintática do compilador. Para fazer qualquer coisa útil, será
  necessário o analisador léxico (executável = lexer), semântico (executável =
  semant) e geração de código (executável = cgen).

  Para testar seu parser em um arquivo "foo.cl", execute o
  seguinte comando:

  > ./myparser foo.cl

  myparser é um arquivo shell script que une os analisadores léxico e
  sintático.

  Para aplicar seu parser aos arquivos good.cl e bad.cl, execute o comando:

  > make dotest

  Se você acredita que seu parser está correto, você pode querer
  rodar o compilador Cool completo. Para tanto, execute o
  seguinte comando:

  > ./mycoolc foo.cl -o foo.s

  mycoolc é um arquivo shell script que une as fases de compilação (léxico,
  sintático, semântico e geração de código). Você tem disponível
  também o coolc, uma versão de referência do compilador de
  Cool, caso queira utilizar:

  > ./coolc foo.cl -o foo.s

  E, caso queira testar o programa gerado, você pode utilizar o
  emulador spim:

  > ./spim -file foo.s

  Para entregar seu trabalho, primeiro certifique-se que está tudo funcionando
  e que você preencheu o arquivo README corretamente. Em seguida, dentro do
  diretório do projeto, execute o seguinte comando (considerando que apenas
  os arquivos a seguir foram modificados):

  > tar -czvf tp3_seuNOME.tar.gz cool.y good.cl bad.cl README

  BOA SORTE!

------8<------8<------8<------8<---corte arqui---8<------8<------8<------8<-----
O presente trabalho tem como objetivo construir o parser para cool, a especificação da sintaxe do cool pode ser consultada em: The Cool Reference Manual (https://web.stanford.edu/class/cs143/materials/cool-manual.pdf).
Primeiramente as regras de Parsing são determinadas:
De acordo com a definição de nós de AST em cool-tree.aps as regras de parsing são escritas facilmente em cool.y. Como exemplo a definição do construtor de classe:

##########################################################################cpp
constructor class_(name : Symbol; parent: Symbol;
    features : Features; filename : Symbol): Class_;
#############################################################################
a regra de parsing é:

##########################################################################cpp
class   : CLASS TYPEID '{' feature_list '}' ';' {
            $$ = class_($2, idtable.add_string("Object"), 
                $4, stringtable.add_string(curr_filename));
        }
        | CLASS TYPEID INHERITS TYPEID '{' feature_list '}' ';' {
            $$ = class_($2, $4, $6,
                stringtable.add_string(curr_filename));
        }
        ;
#############################################################################

A lista Phyla tem um conjunto distinto de operações para construir e acessar listas. Para cada filo denominado X, exite outro dneominado Xs de tipo list[X], exceto para classes, que é uma lista de nós de classe. As funções da lista são criadas automaticamente para cada lista.

A função nil_***() retorna uma lista vazia do tipo phylum. A função single_***() faz uma lista de comprimento 1 de seu argumento de seu phylum. A função append_***() anexa
duas listas de phylums. Por exemplo formal_list cujo tipo é Formals:
############################################################################cpp
formal_list : {
                $$ = nil_Formals();
            }
            | formal {
                $$ = single_Formals($1);
            }
            | formal_list ',' formal {
                $$ = append_Formals($1, single_Formals($3));
            }
            ;
###############################################################################

Após ter completado todas as regras de análise em cool.y digite make parser para construir o analisador. Yacc produz um dump legível das tabelas de análise LALR(1) em cool.output.
A construção Cool let introduz uma ambiguidade na linguagem. O manual resolve a ambiguidade dizendo que uma expressão let se estende o mais a direita possível.

Se houver um erro em uma definição de classe, mas a classe for encerrada corretamente e a próxima classe estiver sintaticamente correta, o analisador deverá ser capaz de
reiniciar na próxima definição de classe.

Da mesma forma, o analisador deve se recuperar de erros em recursos, indo para o próximo recurso, uma ligação let para a próxima variável e uma expressão dentro de um bloco.
Portanto um pseudo-notermina 'error' deve ser adicionado para a produção de classe, recurso e assim por diante.


judge.sh é um judge script que compara a saída de parser (./parser) com a referência parser (../../bin/.i686/parser).

rode ./judge.sh ou bash judge.sh, os resultados serão:

#######################################################################################
--------Test using ../../examples/arith.cl --------
Passed
--------Test using ../../examples/atoi.cl --------
Passed
--------Test using ../../examples/atoi_test.cl --------
Passed
--------Test using ../../examples/book_list.cl --------
Passed
--------Test using ../../examples/cells.cl --------
Passed
--------Test using ../../examples/complex.cl --------
Passed
--------Test using ../../examples/cool.cl --------
Passed
--------Test using ../../examples/good.cl --------
Passed
--------Test using ../../examples/graph.cl --------
Passed
--------Test using ../../examples/hairyscary.cl --------
Passed
--------Test using ../../examples/hello_world.cl --------
Passed
--------Test using ../../examples/io.cl --------
Passed
--------Test using ../../examples/lam.cl --------
Passed
--------Test using ../../examples/life.cl --------
Passed
--------Test using ../../examples/list.cl --------
Passed
--------Test using ../../examples/new_complex.cl --------
Passed
--------Test using ../../examples/palindrome.cl --------
Passed
--------Test using ../../examples/primes.cl --------
Passed
--------Test using ../../examples/sort_list.cl --------
Passed
###############################################################################################

