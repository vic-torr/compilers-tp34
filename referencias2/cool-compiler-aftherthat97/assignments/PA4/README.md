README file for Programming Assignment 4 (C++ edition)
======================================================

Your directory should now contain the following files:

```
Makefile
README
ast-lex.cc		-> [cool root]/src/PA4/ast-lex.cc
ast-parse.cc		-> [cool root]/src/PA4/ast-parse.cc
bad.cl
cgen			-> [cool root]/etc/../lib/.i
cool-tree.cc		-> [cool root]/src/PA4/cool-tree.cc
cool-tree.h
cool-tree.handcode.h
dumptype.cc		-> [cool root]/src/PA4/dumptype.cc
good.cl
handle_flags.cc	-> [cool root]/src/PA4/handle_flags.cc
mycoolc		-> [cool root]/src/PA4/mycoolc
mysemant		-> [cool root]/src/PA4/mysemant
semant-phase.cc	-> [cool root]/src/PA4/semant-phase.cc
semant.cc
semant.h
stringtab.cc		-> [cool root]/src/PA4/stringtab.cc
symtab_example.cc	-> [cool root]/src/PA4/symtab_example.cc
tree.cc		-> [cool root]/src/PA4/tree.cc
utilities.cc		-> [cool root]/src/PA4/utilities.cc
*.d			  dependency files
```

```
The include (.h) files for this assignment can be found in 
[cool root]/include/PA4

The Makefile contains targets for compiling and running your
program. DO NOT MODIFY.

The README contains this info. Part of the assignment is to fill
the README with the write-up for your project. You should
explain design decisions, explain why your code is correct, and
why your test cases are adequate. It is part of the assignment
to clearly and concisely explain things in text as well as to
comment your code.  Just edit this file.

good.cl and bad.cl test a few features of the semantic checker.
You should add tests to ensure that good.cl exercises as many
legal semantic combinations as possible and that bad.cl
exercises as many kinds of semantic errors as possible.

semant.h contains declarations and definitions for the semantic
analyzer.  Place class definitions for the structures you will
use here.

cool-tree.aps contains the definitions for the tree language
which you use to construct the abstract syntax tree (AST).
From this file, cool-tree.h and cool-tree.cc are automatically 
generated by a utility that compiles the specification into
C++ functions for producing and consuming the tree nodes.
This file is provided for your reference.  DO NOT MODIFY.

tree.{cc|h} contain definitions used by the tree package.  DO
NOT MODIFY.

cool-tree.h, and cool-tree.handcode.h specify and give an
implementation of Cool ASTs (see the README for PA3 and the
"Cool Tour").  In this assignment, you will need to add
functions to the AST classes to store, fetch, and compute
information about the AST.  Note that cool-tree.handcode.h
differs slightly from the file supplied for PA3.

You should NOT remove any definitions that are already present
in cool-tree.h and cool-tree.handcode.h.  These functions and
data members are required for the system to function properly.

You should add any fields and methods to the classes you need to 
perform semantic analysis.  You	will need to add, for example, 
methods which traverse the expressions of the tree and implement 
the type-checking rules.

cool-tree.cc contains definitions of the provided methods,
and instantiations of the template for the list handling functions.
You should not modify this file, but place definitions of all
methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
DO NOT MODIFY cool-tree.cc

semant.cc is the file in which you should write your semantic
analyzer.  The main() procedure calls the method `semant'
on `ast_root', the root of the abstract syntax tree generated by
the parser.  There are methods supplied that you should use to report 
errors. You are relatively free in how you decide to structure the 
semantic checker, but don't modify the error printing routines.

ast-lex.cc and ast-parse.cc implement a lexer and a parser for
reading text representation of ASTs from console in the format
produced by the parser phase. DO NOT MODIFY.

semant-phase.cc contains a test driver for semantic analysis.
The main program reads an AST in text form from standard input,
parses it, and then produces a type-annotated AST on standard
output.  The script mycoolc can pass any of the standard flags
to the semantic analyzer as well; for this assignment, -s
(semantic analysis debug) may be useful as it sets a global
variable semant_debug to true (1).  If you want your semantic
checker to print debug information when the option is set, write
your debug code in the following format:

      if (semant_debug)
      {
        ...
      }

semant_debug is provided as a convenience. You don't need to use
the debugging flags if you don't want to. DON'T MODIFY
semant-phase.cc

symtab.h contains a symbol table implementation. Read the
comments in the file, the "Cool Tour", and look at the example
in symtab_example.cc.  You are not required to use this code,
but you may find it useful. DO NOT MODIFY.
```

Instructions
------------

```
To compile the example use of the symbol table, type

% make symtab_example
% ./symtab_example

To compile your semantic analyzer program type:

% make semant

To test your semantic checker, type:

% ./mysemant good.cl

mysemant is a version of mycoolc that omits code generation.
mysemant parses all the cool files given on the command line and
builds a single abstract syntax tree containing all class
definitions appearing in the input files. Your semantic checker
is then called on this abstract syntax tree.  If there are no
errors, the program produces a type-annotated abstract syntax
tree as output.

To run your checker on the files good.cl and bad.cl type:

% make dotest

If you think your semantic checker is correct and behaves like
the one we wrote, you can try to run mycoolc using your checker,
your parser and also your lexical analyzer if you choose (see
below for instructions).  Remember if your lexer, parser or
checker behaves in an unexpected manner, you may get errors
anywhere.

If you change architectures you must issue

% make clean

when you switch from one type of machine to the other.
If at some point you get weird errors from the linker,	
you probably forgot this step.

GOOD LUCK!
```

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

Type checking for Cool includes:

### Class

* [x] Add 5 basic classes (`Object`, `IO`, `Int`, `Bool`, `Str`) to class table
* [x] Check if class `Main` and method `main` is defined (expected)
* [x] Check if `SELF_TYPE` is defined (not expected)
* [x] Check class or method redefinition (not expected)
* [x] Check if any class inherits from `Int`, `Str`, `Bool`, `SELF_TYPE`, or an undefined class (not expected)
* [x] Check if its parent class (`Object` by default) exists (expected)
* [x] Check inheritance cycle (not expected)

### Method

* [x] Check if the number of arguments, the types of the formal parameters, and the return type are exactly the same when a class trys to override the inherited method from an ancestor class
* [x] Check if `self` is the name of some formal parameter (not expected)
* [x] Check formal parameter redefinition (not expected)
* [x] Check if the declared type of formal parameter is defined (expected)
* [x] Check if the return type is defined (expected)
* [x] Check if the inferred return type conforms to the declared return type (expected)

### Attribute

* [x] Check if the declared type of attribute is defined (expected)
* [x] Check if the inferred type of initialization of attribute (if exists) conforms to its declared type (expected)

### Assign

* [x] Check if the identifier is declared (expected)
* [x] Check if the type of assigned expression conforms to declared type of identifier (expected)

### Dispatch

* [x] Check if the declared static dispatch type is defined (only for static dispatch, expected)
* [x] Check if the expression type is defined (expected)
* [x] Check if the expression type conforms to the declared static dispatch type (only for static dispatch, expected)
* [x] Check if the method is defined (expected)
* [x] Check if the types of actual parameters conform to the declared type of formal parameters in call of method (expected)
* [x] Check if the number of arguments match in call of method (expected)

### Cond & Loop

* [x] Check if the condition has type `Bool` (expected)

### Case / Branch

* [x] Check if duplicate branch exists (not expected)

### Let

* [x] Check if the declared type of identifier is defined (expected)
* [x] Check if the inferred type of initialization of identifier (if exists) conforms to its declared type (expected)

### Plus, Sub, Mul, Div, Neg, LT, LEQ (+, -, *, /, ~, <, <=)

* [x] Check if all arguments have type `Int` (expected)

### EQ (=)

* [x] Check if one argument has static type `Int`, ` Bool`, or `String`, then the other must have the same static type

### Comp (not)

* [x] Check if argument has type `Bool` (expected)

### New

* [x] Check if `new` is used with undefined class (not expected)

### Object

* [x] Check if identifier is declared (expected)

## Judge

`judge.sh` is a judge script which compares the output of my semant (`./semant`) with the reference semant (`../../bin/.i686/semant`).

Run `./judge.sh` or `bash judge.sh`, you should get the following results:

```
--------Test using bad_examples/bad.cl --------
Passed
--------Test using bad_examples/bad_class_names.cl --------
Passed
--------Test using bad_examples/bad_dispatch.cl --------
Passed
--------Test using bad_examples/bad_inheritance.cl --------
Passed
--------Test using bad_examples/bad_override.cl --------
2c2
< bad_examples/bad_override.cl:14: In redefined method add, parameter type Bool is different from original type Int
---
> bad_examples/bad_override.cl:14: In redefined method add, parameter type Bool is different from original type Int.
--------Test using bad_examples/inheritance_cycle.cl --------
Passed
--------Test using bad_examples/miss_Main.cl --------
Passed
--------Test using bad_examples/miss_main.cl --------
Passed
--------Test using good_examples/arith.cl --------
Passed
--------Test using good_examples/atoi.cl --------
Passed
--------Test using good_examples/atoi_test.cl --------
Passed
--------Test using good_examples/book_list.cl --------
Passed
--------Test using good_examples/cells.cl --------
Passed
--------Test using good_examples/complex.cl --------
Passed
--------Test using good_examples/cool.cl --------
Passed
--------Test using good_examples/good.cl --------
Passed
--------Test using good_examples/graph.cl --------
Passed
--------Test using good_examples/hairyscary.cl --------
Passed
--------Test using good_examples/hello_world.cl --------
Passed
--------Test using good_examples/io.cl --------
Passed
--------Test using good_examples/lam.cl --------
Passed
--------Test using good_examples/life.cl --------
Passed
--------Test using good_examples/list.cl --------
Passed
--------Test using good_examples/new_complex.cl --------
Passed
--------Test using good_examples/palindrome.cl --------
Passed
--------Test using good_examples/primes.cl --------
Passed
--------Test using good_examples/sort_list.cl --------
Passed
```
