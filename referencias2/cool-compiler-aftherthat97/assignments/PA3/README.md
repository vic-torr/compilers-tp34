README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

```
Makefile
README
cool.y
bad.cl
good.cl
cool-tree.handcode.h
cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
tree.cc		  -> [cool root]/src/PA3/tree.cc
utilities.cc		  -> [cool root]/src/PA3/utilities.cc
*.d			  dependency files
*.*			  other generated files
```

```
The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

The Makefile contains targets for compiling and running your
program. DO NOT MODIFY.

The README contains this info. Part of the assignment is to
fill in the README with the write-up for your project. You should
explain design decisions, explain why your code is correct, and why
your test cases are adequate. It is part of the assignment to
clearly and concisely explain things in text as well as to comment
your code. Just edit this file.

cool.y is the skeleton for the parser specification that you
are to write. It already contains productions for the program
and the classes. Use them as an example to write the remaining
productions.  You should also read the bison documentation.
This skeleton will compile and run as is, but it doesn't
do much.

good.cl, bad.cl test a few features of the grammar. You should
add tests to ensure that good.cl exercises every legal
construction of the grammar and that bad.cl exercises as many
different parsing errors as you can squeeze into one file.

cool-tree.aps contains the definitions for the tree language
which you use to construct the abstract syntax tree (AST).
From this file, cool-tree.h and cool-tree.cc are automatically 
generated by a utility that compiles the specification into
C++ functions for producing and consuming the tree nodes.
This file is provided for your reference.  DO NOT MODIFY.

tree.{cc|h} contain definitions used by the tree package.
cool-tree.handcode.h is the handwritten extension to
cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
note that there are "hooks" for extending the classes
declarations.  Extending and modifying the tree package is
discussed in the "Cool Tour", but you do not need to (and should
not) modify the tree package for this assignment.

tokens-lex.cc is a lexer capable of reading a token stream from
console in the format produced by the lexer phase. DO NOT
MODIFY.

parser-phase.cc contains a driver to test the parser. DO NOT
MODIFY.

dumptype.cc prints the AST out in a form readable by the
semant phase of the compiler. DO NOT MODIFY.

handle_flags.cc implements routines for parsing command line
flags. DO NOT MODIFY.

The rest of the files are created as byproducts of `bison'.
`cool-parse.cc' is the generated C++ file containing the
parser.

Files not discussed are covered in the README for PA2.
```

Instructions
------------

```
To compile your parser program type:

% make parser

This produces an executable named "parser" which is standalone
phase of the Cool compiler.  It requires lexer, semant, and cgen
to do anything useful.

To test your parser on a file 'foo.cl' type

% myparser foo.cl

myparser is a shell script that "glues" together lexer and
parser using pipes.

To run your parser on the files good.cl and bad.cl type:

% make dotest

To run the (provided) lexer and your parser on a file called test.cl type:

% ./lexer test.cl | ./parser

If you think your parser is correct and behaves like
the one we wrote, you may want to run a COOL compiler using
your parser:

% mycoolc foo.cl

To overwrite the default lexical analyzer with yours, replace 
lexer (which is a symbolic link to the "official" lexer) with
    your lexer from PA2.

If you change architectures you must issue

% make clean

when you switch from one type of machine to the other.
If at some point you get weird errors from the linker,	
you probably forgot this step.

GOOD LUCK!
```

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

Cool syntax specification can be found in [The Cool Reference Manual](http://web.stanford.edu/class/cs143/materials/cool-manual.pdf). (Page 17)

### Write Parsing Rules

According to the definition of AST nodes in `cool-tree.aps`, you can write parsing rules easily in `cool.y`. For example, the definition of the constructor of `class` is as follows:

```cpp
constructor class_(name : Symbol; parent: Symbol;
    features : Features; filename : Symbol): Class_;
```

The parsing rule is as follows:

```cpp
class   : CLASS TYPEID '{' feature_list '}' ';' {
            $$ = class_($2, idtable.add_string("Object"), 
                $4, stringtable.add_string(curr_filename));
        }
        | CLASS TYPEID INHERITS TYPEID '{' feature_list '}' ';' {
            $$ = class_($2, $4, $6,
                stringtable.add_string(curr_filename));
        }
        ;
```

Attention that list phyla have a distinct set of operations for constructing and accessing lists. For each phylum named X there is a phylum called Xs (except for `Classes`, which is a list of Class nodes) of type List[X]. List functions are defined automatically for each list.

The function `nil_***()` returns an empty list of type phylum. The function `single_***()` makes a list of length 1 out of its phylum argument. The function `append_***()` appends two lists of phylums. For the example of `formal_list`, whose type is `Formals`:

```cpp
formal_list : {
                $$ = nil_Formals();
            }
            | formal {
                $$ = single_Formals($1);
            }
            | formal_list ',' formal {
                $$ = append_Formals($1, single_Formals($3));
            }
            ;
```

When you have completed all the parsing rules in `cool.y`, type `make parser` to build the parser. Yacc produces a human-readable dump of the LALR(1) parsing tables in the `cool.output`. You can check whether your parser has any shift-reduce conflicts.

The Cool `let` construct introduces an ambiguity into the language. The manual resolves the ambiguity by saying that a `let` expression extends as far to the right as possible.

### Error Handling

- If there is an error in a class definition but the class is terminated properly and the next class is syntactically correct, the parser should be able to restart at the next class definition.
- Similarly, the parser should recover from errors in features (going on to the next feature), a `let` binding (going on to the next variable), and an expression inside a `{...}` block.

So you should add the `error` pseudo-nontermina to the production of class, feature, and so on.

## Judge

`judge.sh` is a judge script which compares the output of my parser (`./parser`) with the reference parser (`../../bin/.i686/parser`).

Run `./judge.sh` or `bash judge.sh`, you should get the following results:

```
--------Test using ../../examples/arith.cl --------
Passed
--------Test using ../../examples/atoi.cl --------
Passed
--------Test using ../../examples/atoi_test.cl --------
Passed
--------Test using ../../examples/book_list.cl --------
Passed
--------Test using ../../examples/cells.cl --------
Passed
--------Test using ../../examples/complex.cl --------
Passed
--------Test using ../../examples/cool.cl --------
Passed
--------Test using ../../examples/good.cl --------
Passed
--------Test using ../../examples/graph.cl --------
Passed
--------Test using ../../examples/hairyscary.cl --------
Passed
--------Test using ../../examples/hello_world.cl --------
Passed
--------Test using ../../examples/io.cl --------
Passed
--------Test using ../../examples/lam.cl --------
Passed
--------Test using ../../examples/life.cl --------
Passed
--------Test using ../../examples/list.cl --------
Passed
--------Test using ../../examples/new_complex.cl --------
Passed
--------Test using ../../examples/palindrome.cl --------
Passed
--------Test using ../../examples/primes.cl --------
Passed
--------Test using ../../examples/sort_list.cl --------
Passed
```
