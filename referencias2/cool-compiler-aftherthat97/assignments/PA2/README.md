README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should contain the following files:

```
Makefile
README
cool.flex
test.cl
lextest.cc      -> [cool root]/src/PA2/lextest.cc
mycoolc         -> [cool root]/PA2/mycoolc
stringtab.cc    -> [cool root]/PA2/stringtab.cc
utilities.cc    -> [cool root]/PA2/utilities.cc
handle_flags.cc -> [cool root]/PA2/handle_flags.cc
*.d             dependency files
*.*             other generated files
```

```
The include (.h) files for this assignment can be found in 
[cool root]/PA2

The Makefile contains targets for compiling and running your
program. DO NOT MODIFY.

The README contains this info. Part of the assignment is to fill
the README with the write-up for your project. You should
explain design decisions, explain why your code is correct, and
why your test cases are adequate. It is part of the assignment
to clearly and concisely explain things in text as well as to
comment your code. Just edit this file.

cool.flex is a skeleton file for the specification of the
lexical analyzer. You should complete it with your regular
expressions, patterns and actions. 

test.cl is a COOL program that you can test the lexical
analyzer on. It contains some errors, so it won't compile with
coolc. However, test.cl does not exercise all lexical
constructs of COOL and part of your assignment is to rewrite
test.cl with a complete set of tests for your lexical analyzer.

cool-parse.h contains definitions that are used by almost all parts
of the compiler. DO NOT MODIFY.

stringtab.{cc|h} and stringtab_functions.h contains functions
    to manipulate the string tables.  DO NOT MODIFY.

utilities.{cc|h} contains functions used by the main() part of
the lextest program. You may want to use the strdup() function
defined in here. Remember that you should not print anything
from inside cool.flex! DO NOT MODIFY.

lextest.cc contains the main function which will call your
lexer and print out the tokens that it returns.  DO NOT MODIFY.

mycoolc is a shell script that glues together the phases of the
compiler using Unix pipes instead of statically linking code.  
While inefficient, this architecture makes it easy to mix and match
the components you write with those of the course compiler.
DO NOT MODIFY.	

    cool-lexer.cc is the scanner generated by flex from cool.flex.
    DO NOT MODIFY IT, as your changes will be overritten the next
    time you run flex.

The *.d files are automatically generated Makefiles that capture
dependencies between source and header files in this directory.
These files are updated automatically by Makefile; see the gmake
documentation for a detailed explanation.
```

Instructions
------------

```
To compile your lextest program type:

% make lexer

Run your lexer by putting your test input in a file 'foo.cl' and
run the lextest program:

% ./lexer foo.cl

To run your lexer on the file test.cl type:

% make dotest

If you think your lexical analyzer is correct and behaves like
the one we wrote, you can actually try 'mycoolc' and see whether
it runs and produces correct code for any examples.
If your lexical analyzer behaves in an
unexpected manner, you may get errors anywhere, i.e. during
parsing, during semantic analysis, during code generation or
only when you run the produced code on spim. So beware.

If you change architectures you must issue

% make clean

when you switch from one type of machine to the other.
If at some point you get weird errors from the linker,	
you probably forgot this step.

GOOD LUCK!
```

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------

Lexical analysis includes:

### White Space

White space consists of any sequence of the characters: blank (ascii 32), `\n` (newline, ascii 10), `\f` (form feed, ascii 12), `\r` (carriage return, ascii 13), `\t` (tab, ascii 9), `\v` (vertical tab, ascii 11).

All these charaters are ignored except for the newline charater: `\n`, which is needed for counting line numbers.

### Comments

There are two forms of comments in Cool. Any characters between two dashes `--` and the end of this line are treated as comments (just like `//` in C). Comments may also be written by enclosing text in `(*`...`*)` (just like `/*` and `*/` in C). The latter form of comment may be nested. Comments cannot cross file boundaries.

- Comments should be ignored.
- If a comment remains open when EOF is encountered, report this error with the message "EOF in comment".
- If you see  `*)`  outside a comment, report this error as "Unmatched \*)", rather than tokenizing it as `*` and `)`.

### Operators and Separators

Return itself as a `char` if it is a single-charater operator or Separator. As for the others with two charaters, return the value as it is defined in `cool-parse.h`.

### Keywords

The keywords of cool are: `class`, `else`, `false`, `fi`, `if`, `in`, `inherits`, `isvoid`, `let`, `loop`, `pool`, `then`, `while`, `case`, `esac`, `new`, `of`, `not`, `true`. Except for the constants `true` and `false`, keywords are case insensitive. To conform to the rules for other objects, the first letter of `true` and `false` must be lowercase; the trailing letters may be upper or lower case.

### Strings

The type `Char` is invalid in cool. Single charater and string both should be defined as `String`. Strings are enclosed in double quotes `"`...`"`.

- If an EOF is encountered before the close-quote, report this error as "EOF in string constant".
- When a string is too long (exceed `MAX_STR_CONST`), report this error as "String constant too long".
- You must return an error as "String contains null character" for a string containing
  the literal null character. However, the sequence of two characters `\` `0` is allowed but should be converted to the one character `\0`, which represents the null charater.
- Your scanner should convert escape characters in string constants to their correct values.
- If a string contains an unescaped newline, report that error as "Unterminated string constant" and resume lexing at the beginning of the next line.

Example of one invlid expression:

```bash
//Invalid
str = "123
456";
```

The valid expression should be as follows:

```bash
//Valid
str = "123\n456";
```

This is also valid:

```bash
//Valid
str = "123\
456";
```

### Integers

Integers are non-empty strings of digits 0-9.

### Identifiers

Identifiers are strings (other than keywords) consisting of letters, digits, and the underscore character. Type identifiers begin with a capital letter; object identifiers begin with a lower case letter. There are two other identifiers, `self` and `SELF_TYPE` that are treated specially by Cool but are not treated as keywords.

### Others

Just return an error with this token.

## Judge

`judge.sh` is a judge script which compares the output of my lexer (`./lexer`) with the reference lexer (`../../bin/.i686/lexer`).

Run `./judge.sh` or `bash judge.sh`, you should get the following results:

```
--------Test using ../../examples/arith.cl --------
Passed
--------Test using ../../examples/atoi.cl --------
Passed
--------Test using ../../examples/atoi_test.cl --------
Passed
--------Test using ../../examples/book_list.cl --------
Passed
--------Test using ../../examples/cells.cl --------
Passed
--------Test using ../../examples/complex.cl --------
Passed
--------Test using ../../examples/cool.cl --------
Passed
--------Test using ../../examples/good.cl --------
Passed
--------Test using ../../examples/graph.cl --------
Passed
--------Test using ../../examples/hairyscary.cl --------
Passed
--------Test using ../../examples/hello_world.cl --------
Passed
--------Test using ../../examples/io.cl --------
Passed
--------Test using ../../examples/lam.cl --------
Passed
--------Test using ../../examples/life.cl --------
Passed
--------Test using ../../examples/list.cl --------
Passed
--------Test using ../../examples/new_complex.cl --------
Passed
--------Test using ../../examples/palindrome.cl --------
Passed
--------Test using ../../examples/primes.cl --------
Passed
--------Test using ../../examples/sort_list.cl --------
Passed
```
